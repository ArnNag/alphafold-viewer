"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.alignMotifs = void 0;
var tslib_1 = require("tslib");
var ALIGNMENT_URL = 'https://alignment.rcsb.org/api/v1-beta/';
function alignMotifs(query, hit) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var q, formData, r, uuid, url, result, _a, alignment_summary, blocks;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    q = {
                        options: {
                            return_sequence_data: false
                        },
                        context: {
                            mode: 'pairwise',
                            method: {
                                name: 'qcp',
                                parameters: {
                                    atom_pairing_strategy: 'all'
                                }
                            },
                            structures: [
                                {
                                    entry_id: query.entry_id,
                                    residue_ids: convertToPecosIdentifiers(query.residue_ids)
                                },
                                {
                                    entry_id: hit.entry_id,
                                    residue_ids: convertToPecosIdentifiers(hit.residue_ids)
                                }
                            ]
                        }
                    };
                    formData = new FormData();
                    formData.append('query', JSON.stringify(q));
                    return [4 /*yield*/, fetch(ALIGNMENT_URL + 'structures/submit', { method: 'POST', body: formData })];
                case 1:
                    r = _b.sent();
                    if (r.status !== 200) {
                        throw new Error('Failed to submit the job');
                    }
                    return [4 /*yield*/, r.text()];
                case 2:
                    uuid = _b.sent();
                    url = ALIGNMENT_URL + 'structures/results?uuid=' + uuid;
                    return [4 /*yield*/, pollUntilDone(url, 25, 10 * 1000)];
                case 3:
                    result = _b.sent();
                    _a = result.results[0], alignment_summary = _a.alignment_summary, blocks = _a.blocks;
                    return [2 /*return*/, { rmsd: alignment_summary.scores[0].value, matrix: blocks[0].transformations[0] }];
            }
        });
    });
}
exports.alignMotifs = alignMotifs;
// convert strucmotif/arches residue identifiers to the pecos/sierra flavor
function convertToPecosIdentifiers(identifiers) {
    return identifiers.map(function (i) {
        var o = Object.create(null);
        Object.assign(o, {
            asym_id: i.label_asym_id,
            seq_id: i.label_seq_id
        });
        if (i.struct_oper_id)
            Object.assign(o, { struct_oper_id: i.struct_oper_id });
        return o;
    });
}
// create a promise that resolves after a short delay
function delay(t) {
    return new Promise(function (resolve) {
        setTimeout(resolve, t);
    });
}
/**
 * Poll until results are available.
 * @param url is the URL to request
 * @param interval is how often to poll
 * @param timeout is how long to poll waiting for a result (0 means try forever)
 */
function pollUntilDone(url, interval, timeout) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        function run() {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var r, data;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, fetch(url)];
                        case 1:
                            r = _a.sent();
                            return [4 /*yield*/, r.json()];
                        case 2:
                            data = _a.sent();
                            if (data.info.status === 'COMPLETE') {
                                // we know we're done here, return from here whatever you
                                // want the final resolved value of the promise to be
                                return [2 /*return*/, data];
                            }
                            else if (data.info.status === 'ERROR') {
                                throw new Error('Failed to complete the job. Error: ' + data.info.message);
                            }
                            else {
                                if (timeout !== 0 && Date.now() - start > timeout) {
                                    throw new Error('timeout error on pollUntilDone');
                                }
                                else {
                                    // run again with a short delay
                                    return [2 /*return*/, delay(interval).then(run)];
                                }
                            }
                            return [2 /*return*/];
                    }
                });
            });
        }
        var start;
        return tslib_1.__generator(this, function (_a) {
            start = Date.now();
            return [2 /*return*/, run()];
        });
    });
}
