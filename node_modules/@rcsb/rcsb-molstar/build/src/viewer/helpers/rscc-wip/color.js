"use strict";
// /**
//  * Copyright (c) 2022 mol* contributors, licensed under MIT, See LICENSE file for more info.
//  *
//  * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>
//  */
//
// import { Color } from 'molstar/lib/mol-util/color';
// import { TableLegend } from 'molstar/lib/mol-util/legend';
// import { ThemeDataContext } from 'molstar/lib/mol-theme/theme';
// import { ColorTheme, LocationColor } from 'molstar/lib/mol-theme/color';
// import { StructureElement } from 'molstar/lib/mol-model/structure/structure';
// import { Bond, Unit } from 'molstar/lib/commonjs/mol-model/structure/structure';
// import { CustomProperty } from 'molstar/lib/mol-model-props/common/custom-property';
// import { ParamDefinition as PD } from 'molstar/lib/mol-util/param-definition';
//
// const DefaultColor = Color(0xaaaaaa);
// const ConfidenceColors: { [k: string]: Color } = {
//     'No Score': DefaultColor,
//     'Very low': Color(0xff7d45),
//     'Low': Color(0xffdb13),
//     'Well resolved': Color(0x65cbf3),
//     'Very well resolved': Color(0x0053d6)
// };
//
// const ConfidenceColorLegend = TableLegend(Object.entries(ConfidenceColors));
//
// export function getRSCCColorThemeParams(ctx: ThemeDataContext) {
//     return {};
// }
// export type RSCCColorThemeParams = ReturnType<typeof getRSCCColorThemeParams>
//
// export function RSCCColorTheme(ctx: ThemeDataContext, props: PD.Values<RSCCColorThemeParams>): ColorTheme<RSCCColorThemeParams> {
//     let color: LocationColor = () => DefaultColor;
//
//     if (ctx.structure) {
//         const l = StructureElement.Location.create(ctx.structure.root);
//
//         const getColor = (location: StructureElement.Location): Color => {
//             const { unit, element } = location;
//             if (!Unit.isAtomic(unit)) return DefaultColor;
//             const rscc = RSCCProvider.get(unit.model).value;
//             const score = rscc?.get(unit.model.atomicHierarchy.residueAtomSegments.index[element]) ?? -1;
//             if (score < 0) {
//                 return DefaultColor;
//             } else if (score <= 50) {
//                 return Color(0xff7d45);
//             } else if (score <= 70) {
//                 return Color(0xffdb13);
//             } else if (score <= 90) {
//                 return Color(0x65cbf3);
//             } else {
//                 return Color(0x0053d6);
//             }
//         };
//
//         color = (location: Location) => {
//             if (StructureElement.Location.is(location)) {
//                 return getColor(location);
//             } else if (Bond.isLocation(location)) {
//                 l.unit = location.aUnit;
//                 l.element = location.aUnit.elements[location.aIndex];
//                 return getColor(l);
//             }
//             return DefaultColor;
//         };
//     }
//
//     return {
//         factory: RSCCColorTheme,
//         granularity: 'group',
//         preferSmoothing: true,
//         color,
//         props,
//         description: 'Assigns residue colors according to the real-space correlation coefficient (RSCC).',
//         legend: ConfidenceColorLegend
//     };
// }
//
// export const RSCCColorThemeProvider: ColorTheme.Provider<RSCCColorThemeParams, 'rscc'> = {
//     name: 'rscc',
//     label: 'Real-Space Correlation Coefficient',
//     category: ColorTheme.Category.Validation,
//     factory: RSCCColorTheme,
//     getParams: getRSCCColorThemeParams,
//     defaultValues: PD.getDefaultValues(getRSCCColorThemeParams({})),
//     isApplicable: (ctx: ThemeDataContext) => !!ctx.structure?.models.some(m => RSCC.isApplicable(m)),
//     ensureCustomProperties: {
//         attach: async (ctx: CustomProperty.Context, data: ThemeDataContext) => {
//             if (data.structure) {
//                 for (const m of data.structure.models) {
//                     await RSCCProvider.attach(ctx, m, void 0, true);
//                 }
//             }
//         },
//         detach: async (data: ThemeDataContext) => {
//             if (data.structure) {
//                 for (const m of data.structure.models) {
//                     RSCCProvider.ref(m, false);
//                 }
//             }
//         }
//     }
// };
