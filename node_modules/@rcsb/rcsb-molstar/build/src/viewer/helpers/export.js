"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadAsZipFile = exports.encodeStructureData = void 0;
var tslib_1 = require("tslib");
var mol_state_1 = require("molstar/lib/mol-state");
var objects_1 = require("molstar/lib/mol-plugin-state/objects");
var structure_1 = require("molstar/lib/mol-model/structure");
var mmcif_1 = require("molstar/lib/mol-model/structure/export/mmcif");
var utf8_1 = require("molstar/lib/mol-io/common/utf8");
var zip_1 = require("molstar/lib/mol-util/zip/zip");
var date_1 = require("molstar/lib/mol-util/date");
var download_1 = require("molstar/lib/mol-util/download");
var cif_1 = require("molstar/lib/mol-io/writer/cif");
function exportParams() {
    var skipCategories = new Set();
    skipCategories
        // Basics
        .add('entry')
        // Symmetry
        .add('cell')
        .add('symmetry')
        // Secondary structure
        .add('struct_conf')
        .add('struct_sheet_range')
        // Assemblies
        .add('pdbx_struct_assembly')
        .add('pdbx_struct_assembly_gen')
        .add('pdbx_struct_oper_list');
    var params = {
        skipCategoryNames: skipCategories
    };
    return params;
}
function to_mmCIF(name, structure, asBinary) {
    if (asBinary === void 0) { asBinary = false; }
    var enc = cif_1.CifWriter.createEncoder({ binary: asBinary });
    enc.startDataBlock(name);
    (0, mmcif_1.encode_mmCIF_categories)(enc, structure, exportParams());
    return enc.getData();
}
function getDecorator(plugin, root) {
    var tree = plugin.state.data.tree;
    var children = tree.children.get(root);
    if (children.size !== 1)
        return root;
    var child = children.first();
    if (tree.transforms.get(child).transformer.definition.isDecorator) {
        return getDecorator(plugin, child);
    }
    return root;
}
function extractStructureDataFromState(plugin) {
    var content = Object.create(null);
    var cells = plugin.state.data.select(mol_state_1.StateSelection.Generators.rootsOfType(objects_1.PluginStateObject.Molecule.Structure));
    for (var i = 0; i < cells.length; i++) {
        var c = cells[i];
        // get decorated root structure
        var rootRef = getDecorator(plugin, c.transform.ref);
        var rootCell = mol_state_1.StateObjectRef.resolveAndCheck(plugin.state.data, rootRef);
        // get all leaf children of root
        var children = plugin.state.data.tree.children.get(rootRef).toArray()
            .map(function (x) { return plugin.state.data.select(mol_state_1.StateSelection.Generators.byRef(x))[0]; })
            .filter(function (c) { var _a; return ((_a = c.obj) === null || _a === void 0 ? void 0 : _a.type) === objects_1.PluginStateObject.Molecule.Structure.type; })
            .map(function (x) { return x.obj.data; });
        // merge children
        var sele = structure_1.StructureSelection.Sequence(rootCell.obj.data, children);
        var structure = structure_1.StructureSelection.unionStructure(sele);
        var name_1 = "".concat(i + 1, "-").concat(structure.model.entryId);
        content[name_1] = structure;
    }
    return content;
}
function encodeStructureData(plugin) {
    var content = Object.create(null);
    var structures = extractStructureDataFromState(plugin);
    for (var _i = 0, _a = Object.entries(structures); _i < _a.length; _i++) {
        var _b = _a[_i], key = _b[0], structure = _b[1];
        var filename = "".concat(key, ".cif");
        var str = to_mmCIF(filename, structure, false);
        var data = new Uint8Array((0, utf8_1.utf8ByteCount)(str));
        (0, utf8_1.utf8Write)(data, 0, str);
        content[filename] = data;
    }
    return content;
}
exports.encodeStructureData = encodeStructureData;
function downloadAsZipFile(plugin, content) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var filename, buf;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    filename = "mol-star_download_".concat((0, date_1.getFormattedTime)(), ".zip");
                    return [4 /*yield*/, plugin.runTask((0, zip_1.Zip)(content))];
                case 1:
                    buf = _a.sent();
                    (0, download_1.download)(new Blob([buf], { type: 'application/zip' }), filename);
                    return [2 /*return*/];
            }
        });
    });
}
exports.downloadAsZipFile = downloadAsZipFile;
