"use strict";
/**
 * Copyright (c) 2020-2022 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RSCCColorThemeProvider = exports.RSCCColorTheme = void 0;
var param_definition_1 = require("molstar/lib/mol-util/param-definition");
var color_1 = require("molstar/lib/mol-util/color");
var structure_1 = require("molstar/lib/mol-model/structure");
var prop_1 = require("molstar/lib/extensions/rcsb/validation-report/prop");
var legend_1 = require("molstar/lib/mol-util/legend");
var DefaultColor = (0, color_1.Color)(0xaaaaaa);
var Colors = [DefaultColor, (0, color_1.Color)(0xff7d45), (0, color_1.Color)(0xffdb13), (0, color_1.Color)(0x65cbf3), (0, color_1.Color)(0x0053d6)];
var ConfidenceColors = {
    'No Score': Colors[0],
    'Very Low': Colors[1],
    'Low': Colors[2],
    'Well Resolved': Colors[3],
    'Very Well Resolved': Colors[4]
};
var ConfidenceColorLegend = (0, legend_1.TableLegend)(Object.entries(ConfidenceColors));
function RSCCColorTheme(ctx, props) {
    var _a;
    var color = function () { return DefaultColor; };
    var validationReport = ctx.structure && prop_1.ValidationReportProvider.get(ctx.structure.models[0]);
    var contextHash = validationReport === null || validationReport === void 0 ? void 0 : validationReport.version;
    var model = (_a = ctx.structure) === null || _a === void 0 ? void 0 : _a.models[0];
    if ((validationReport === null || validationReport === void 0 ? void 0 : validationReport.value) && model) {
        var resolution = 1.4; // TODO determine
        var rscc_1 = validationReport.value.rscc;
        console.log(rscc_1);
        var residueIndex_1 = model.atomicHierarchy.residueAtomSegments.index;
        var getColor_1 = function (element) {
            var _a;
            var rI = residueIndex_1[element];
            var score = (_a = rscc_1.get(rI)) !== null && _a !== void 0 ? _a : -1;
            console.log("".concat(model.atomicHierarchy.atoms.label_comp_id.value(element), " ").concat(model.atomicHierarchy.residues.label_seq_id.value(rI), " ").concat(score));
            // TODO actual cutoff values
            // TODO make non-polymers gray
            // TODO legend
            if (score < 0) {
                return Colors[0];
            }
            else if (score <= 0.4) {
                return Colors[1];
            }
            else if (score <= 0.8) {
                return Colors[2];
            }
            else if (score <= 0.95) {
                return Colors[3];
            }
            else {
                return Colors[4];
            }
        };
        color = function (location) {
            if (structure_1.StructureElement.Location.is(location) && location.unit.model === model) {
                return getColor_1(location.element);
            }
            else if (structure_1.Bond.isLocation(location) && location.aUnit.model === model) {
                return getColor_1(location.aUnit.elements[location.aIndex]);
            }
            return DefaultColor;
        };
    }
    return {
        factory: RSCCColorTheme,
        granularity: 'group',
        preferSmoothing: true,
        color: color,
        props: props,
        contextHash: contextHash,
        description: 'Assigns residue colors according to the real-space correlation coefficient (RSCC) for polymer residues. Colors range from orange (very low confidence) and yellow (low confidence) to cyan (well resolved) and blue (very well resolved). Categories were obtained by archive-wide statistical analysis. Data from wwPDB Validation Report, obtained via RCSB PDB.',
        legend: ConfidenceColorLegend
    };
}
exports.RSCCColorTheme = RSCCColorTheme;
exports.RSCCColorThemeProvider = {
    name: 'rscc',
    label: 'Real-space correlation coefficient',
    category: "Validation" /* ColorTheme.Category.Validation */,
    factory: RSCCColorTheme,
    getParams: function () { return ({}); },
    defaultValues: param_definition_1.ParamDefinition.getDefaultValues({}),
    isApplicable: function (ctx) { return !!ctx.structure && prop_1.ValidationReport.isApplicable(ctx.structure.models[0]) && structure_1.Model.isFromXray(ctx.structure.models[0]) && structure_1.Model.probablyHasDensityMap(ctx.structure.models[0]); },
    ensureCustomProperties: {
        attach: function (ctx, data) { return data.structure ? prop_1.ValidationReportProvider.attach(ctx, data.structure.models[0], void 0, true) : Promise.resolve(); },
        detach: function (data) { return data.structure && prop_1.ValidationReportProvider.ref(data.structure.models[0], false); }
    }
};
