/**
 * Copyright (c) 2019-2022 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
import { __extends } from "tslib";
import { InterUnitGraph } from '../../../mol-math/graph/inter-unit-graph';
export { InteractionsIntraContacts };
var InteractionsIntraContacts;
(function (InteractionsIntraContacts) {
    /**
     * Note: assumes that feature members of a contact are non-overlapping
     */
    function createElementsIndex(contacts, features, elementsCount) {
        var offsets = new Int32Array(elementsCount + 1);
        var bucketFill = new Int32Array(elementsCount);
        var bucketSizes = new Int32Array(elementsCount);
        var members = features.members, featureOffsets = features.offsets;
        for (var i = 0, il = contacts.edgeCount * 2; i < il; ++i) {
            var aI = contacts.a[i];
            var bI = contacts.b[i];
            if (aI > bI)
                continue;
            for (var j = featureOffsets[aI], jl = featureOffsets[aI + 1]; j < jl; ++j) {
                ++bucketSizes[members[j]];
            }
            for (var j = featureOffsets[bI], jl = featureOffsets[bI + 1]; j < jl; ++j) {
                ++bucketSizes[members[j]];
            }
        }
        var offset = 0;
        for (var i = 0; i < elementsCount; i++) {
            offsets[i] = offset;
            offset += bucketSizes[i];
        }
        offsets[elementsCount] = offset;
        var indices = new Int32Array(offset);
        for (var i = 0, il = contacts.edgeCount * 2; i < il; ++i) {
            var aI = contacts.a[i];
            var bI = contacts.b[i];
            if (aI > bI)
                continue;
            for (var j = featureOffsets[aI], jl = featureOffsets[aI + 1]; j < jl; ++j) {
                var m = members[j];
                var om = offsets[m] + bucketFill[m];
                indices[om] = i;
                ++bucketFill[m];
            }
            for (var j = featureOffsets[bI], jl = featureOffsets[bI + 1]; j < jl; ++j) {
                var m = members[j];
                var om = offsets[m] + bucketFill[m];
                indices[om] = i;
                ++bucketFill[m];
            }
        }
        return { indices: indices, offsets: offsets };
    }
    InteractionsIntraContacts.createElementsIndex = createElementsIndex;
})(InteractionsIntraContacts || (InteractionsIntraContacts = {}));
export { InteractionsInterContacts };
var InteractionsInterContacts = /** @class */ (function (_super) {
    __extends(InteractionsInterContacts, _super);
    function InteractionsInterContacts(map, unitsFeatures) {
        var _this = _super.call(this, map) || this;
        _this.elementKeyIndex = new Map();
        for (var i = 0, il = _this.edges.length; i < il; ++i) {
            var _a = _this.edges[i], unitA = _a.unitA, indexA = _a.indexA;
            var _b = unitsFeatures.get(unitA), offsets = _b.offsets, members = _b.members;
            for (var j = offsets[indexA], jl = offsets[indexA + 1]; j < jl; ++j) {
                var vertexKey = _this.getElementKey(members[j], unitA);
                var e = _this.elementKeyIndex.get(vertexKey);
                if (e === undefined) {
                    _this.elementKeyIndex.set(vertexKey, [i]);
                }
                else {
                    e.push(i);
                }
            }
        }
        return _this;
    }
    InteractionsInterContacts.prototype.getContactIndicesForElement = function (index, unit) {
        return this.elementKeyIndex.get(this.getElementKey(index, unit.id)) || [];
    };
    InteractionsInterContacts.prototype.getElementKey = function (index, unitId) {
        return "".concat(index, "|").concat(unitId);
    };
    return InteractionsInterContacts;
}(InterUnitGraph));
export function interactionTypeLabel(type) {
    switch (type) {
        case 4 /* InteractionType.HydrogenBond */:
            return 'Hydrogen Bond';
        case 6 /* InteractionType.Hydrophobic */:
            return 'Hydrophobic Contact';
        case 5 /* InteractionType.HalogenBond */:
            return 'Halogen Bond';
        case 1 /* InteractionType.Ionic */:
            return 'Ionic Interaction';
        case 7 /* InteractionType.MetalCoordination */:
            return 'Metal Coordination';
        case 2 /* InteractionType.CationPi */:
            return 'Cation-Pi Interaction';
        case 3 /* InteractionType.PiStacking */:
            return 'Pi Stacking';
        case 8 /* InteractionType.WeakHydrogenBond */:
            return 'Weak Hydrogen Bond';
        case 0 /* InteractionType.Unknown */:
            return 'Unknown Interaction';
    }
}
export function featureTypeLabel(type) {
    switch (type) {
        case 0 /* FeatureType.None */:
            return 'None';
        case 1 /* FeatureType.PositiveCharge */:
            return 'Positive Charge';
        case 2 /* FeatureType.NegativeCharge */:
            return 'Negative Charge';
        case 3 /* FeatureType.AromaticRing */:
            return 'Aromatic Ring';
        case 4 /* FeatureType.HydrogenDonor */:
            return 'Hydrogen Donor';
        case 5 /* FeatureType.HydrogenAcceptor */:
            return 'Hydrogen Acceptor';
        case 6 /* FeatureType.HalogenDonor */:
            return 'Halogen Donor';
        case 7 /* FeatureType.HalogenAcceptor */:
            return 'Halogen Acceptor';
        case 8 /* FeatureType.HydrophobicAtom */:
            return 'HydrophobicAtom';
        case 9 /* FeatureType.WeakHydrogenDonor */:
            return 'Weak Hydrogen Donor';
        case 10 /* FeatureType.IonicTypePartner */:
            return 'Ionic Type Partner';
        case 11 /* FeatureType.DativeBondPartner */:
            return 'Dative Bond Partner';
        case 12 /* FeatureType.TransitionMetal */:
            return 'Transition Metal';
        case 13 /* FeatureType.IonicTypeMetal */:
            return 'Ionic Type Metal';
    }
}
export function featureGroupLabel(group) {
    switch (group) {
        case 0 /* FeatureGroup.None */:
            return 'None';
        case 1 /* FeatureGroup.QuaternaryAmine */:
            return 'Quaternary Amine';
        case 2 /* FeatureGroup.TertiaryAmine */:
            return 'Tertiary Amine';
        case 3 /* FeatureGroup.Sulfonium */:
            return 'Sulfonium';
        case 4 /* FeatureGroup.SulfonicAcid */:
            return 'Sulfonic Acid';
        case 5 /* FeatureGroup.Sulfate */:
            return 'Sulfate';
        case 6 /* FeatureGroup.Phosphate */:
            return 'Phosphate';
        case 7 /* FeatureGroup.Halocarbon */:
            return 'Halocarbon';
        case 8 /* FeatureGroup.Guanidine */:
            return 'Guanidine';
        case 9 /* FeatureGroup.Acetamidine */:
            return 'Acetamidine';
        case 10 /* FeatureGroup.Carboxylate */:
            return 'Carboxylate';
    }
}
