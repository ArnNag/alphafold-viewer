/**
 * Copyright (c) 2020-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
import { Loci } from '../mol-model/loci';
import { StructureElement } from '../mol-model/structure';
import { Script } from '../mol-script/script';
import { BitFlags } from '../mol-util/bit-flags';
export { Clipping };
function Clipping(layers) {
    return { layers: layers };
}
(function (Clipping) {
    Clipping.Empty = { layers: [] };
    var Groups;
    (function (Groups) {
        Groups.is = BitFlags.has;
        function create(flags) {
            return BitFlags.create(flags);
        }
        Groups.create = create;
        Groups.Names = {
            'one': 1 /* Flag.One */,
            'two': 2 /* Flag.Two */,
            'three': 4 /* Flag.Three */,
            'four': 8 /* Flag.Four */,
            'five': 16 /* Flag.Five */,
            'six': 32 /* Flag.Six */,
        };
        function isName(name) {
            return name in Groups.Names;
        }
        Groups.isName = isName;
        function fromName(name) {
            switch (name) {
                case 'one': return 1 /* Flag.One */;
                case 'two': return 2 /* Flag.Two */;
                case 'three': return 4 /* Flag.Three */;
                case 'four': return 8 /* Flag.Four */;
                case 'five': return 16 /* Flag.Five */;
                case 'six': return 32 /* Flag.Six */;
            }
        }
        Groups.fromName = fromName;
        function fromNames(names) {
            var f = 0 /* Flag.None */;
            for (var i = 0, il = names.length; i < il; ++i) {
                f |= fromName(names[i]);
            }
            return f;
        }
        Groups.fromNames = fromNames;
        function toNames(groups) {
            var names = [];
            if (Groups.is(groups, 1 /* Flag.One */))
                names.push('one');
            if (Groups.is(groups, 2 /* Flag.Two */))
                names.push('two');
            if (Groups.is(groups, 4 /* Flag.Three */))
                names.push('three');
            if (Groups.is(groups, 8 /* Flag.Four */))
                names.push('four');
            if (Groups.is(groups, 16 /* Flag.Five */))
                names.push('five');
            if (Groups.is(groups, 32 /* Flag.Six */))
                names.push('six');
            return names;
        }
        Groups.toNames = toNames;
    })(Groups = Clipping.Groups || (Clipping.Groups = {}));
    function areEqual(cA, cB) {
        if (cA.layers.length !== cB.layers.length)
            return false;
        for (var i = 0, il = cA.layers.length; i < il; ++i) {
            if (cA.layers[i].groups !== cB.layers[i].groups)
                return false;
            if (!Loci.areEqual(cA.layers[i].loci, cB.layers[i].loci))
                return false;
        }
        return true;
    }
    Clipping.areEqual = areEqual;
    /** Check if layers empty */
    function isEmpty(clipping) {
        return clipping.layers.length === 0;
    }
    Clipping.isEmpty = isEmpty;
    /** Remap layers */
    function remap(clipping, structure) {
        var layers = [];
        for (var _i = 0, _a = clipping.layers; _i < _a.length; _i++) {
            var layer = _a[_i];
            var loci = layer.loci, groups = layer.groups;
            loci = StructureElement.Loci.remap(loci, structure);
            if (!StructureElement.Loci.isEmpty(loci)) {
                layers.push({ loci: loci, groups: groups });
            }
        }
        return { layers: layers };
    }
    Clipping.remap = remap;
    /** Merge layers */
    function merge(clipping) {
        if (isEmpty(clipping))
            return clipping;
        var structure = clipping.layers[0].loci.structure;
        var map = new Map();
        var shadowed = StructureElement.Loci.none(structure);
        for (var i = 0, il = clipping.layers.length; i < il; ++i) {
            var _a = clipping.layers[il - i - 1], loci = _a.loci, groups = _a.groups; // process from end
            loci = StructureElement.Loci.subtract(loci, shadowed);
            shadowed = StructureElement.Loci.union(loci, shadowed);
            if (!StructureElement.Loci.isEmpty(loci)) {
                if (map.has(groups)) {
                    loci = StructureElement.Loci.union(loci, map.get(groups));
                }
                map.set(groups, loci);
            }
        }
        var layers = [];
        map.forEach(function (loci, groups) {
            layers.push({ loci: loci, groups: groups });
        });
        return { layers: layers };
    }
    Clipping.merge = merge;
    /** Filter layers */
    function filter(clipping, filter) {
        if (isEmpty(clipping))
            return clipping;
        var structure = clipping.layers[0].loci.structure;
        var layers = [];
        for (var _i = 0, _a = clipping.layers; _i < _a.length; _i++) {
            var layer = _a[_i];
            var loci = layer.loci, groups = layer.groups;
            // filter by first map to the `filter` structure and
            // then map back to the original structure of the clipping loci
            var filtered = StructureElement.Loci.remap(loci, filter);
            loci = StructureElement.Loci.remap(filtered, structure);
            if (!StructureElement.Loci.isEmpty(loci)) {
                layers.push({ loci: loci, groups: groups });
            }
        }
        return { layers: layers };
    }
    Clipping.filter = filter;
    function ofScript(scriptLayers, structure) {
        var layers = [];
        for (var i = 0, il = scriptLayers.length; i < il; ++i) {
            var _a = scriptLayers[i], script = _a.script, groups = _a.groups;
            var loci = Script.toLoci(script, structure);
            if (!StructureElement.Loci.isEmpty(loci)) {
                layers.push({ loci: loci, groups: groups });
            }
        }
        return { layers: layers };
    }
    Clipping.ofScript = ofScript;
    function ofBundle(bundleLayers, structure) {
        var layers = [];
        for (var i = 0, il = bundleLayers.length; i < il; ++i) {
            var _a = bundleLayers[i], bundle = _a.bundle, groups = _a.groups;
            var loci = StructureElement.Bundle.toLoci(bundle, structure.root);
            layers.push({ loci: loci, groups: groups });
        }
        return { layers: layers };
    }
    Clipping.ofBundle = ofBundle;
    function toBundle(clipping) {
        var layers = [];
        for (var i = 0, il = clipping.layers.length; i < il; ++i) {
            var _a = clipping.layers[i], loci = _a.loci, groups = _a.groups;
            var bundle = StructureElement.Bundle.fromLoci(loci);
            layers.push({ bundle: bundle, groups: groups });
        }
        return { layers: layers };
    }
    Clipping.toBundle = toBundle;
})(Clipping || (Clipping = {}));
